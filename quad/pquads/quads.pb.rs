// @generated
// This file is @generated by prost-build.
/// Quad is in internal representation of quad used by Cayley.
///
/// TODO(dennwc): get rid of legacy fields with first opportunity and bump version
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Quad {
    #[prost(string, tag="1")]
    pub subject: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub predicate: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub object: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub label: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub subject_value: ::core::option::Option<Value>,
    #[prost(message, optional, tag="6")]
    pub predicate_value: ::core::option::Option<Value>,
    #[prost(message, optional, tag="7")]
    pub object_value: ::core::option::Option<Value>,
    #[prost(message, optional, tag="8")]
    pub label_value: ::core::option::Option<Value>,
}
/// WireQuad is a quad that allows any value for it's directions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WireQuad {
    #[prost(message, optional, tag="1")]
    pub subject: ::core::option::Option<Value>,
    #[prost(message, optional, tag="2")]
    pub predicate: ::core::option::Option<Value>,
    #[prost(message, optional, tag="3")]
    pub object: ::core::option::Option<Value>,
    #[prost(message, optional, tag="4")]
    pub label: ::core::option::Option<Value>,
}
/// WireQuadRaw is the same as WireQuad, but doesn't decode underlying values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WireQuadRaw {
    #[prost(bytes="vec", tag="1")]
    pub subject: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub predicate: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="3")]
    pub object: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="4")]
    pub label: ::prost::alloc::vec::Vec<u8>,
}
/// StrictQuad is a quad as described by RDF spec.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StrictQuad {
    #[prost(message, optional, tag="1")]
    pub subject: ::core::option::Option<strict_quad::Ref>,
    #[prost(message, optional, tag="2")]
    pub predicate: ::core::option::Option<strict_quad::Ref>,
    #[prost(message, optional, tag="3")]
    pub object: ::core::option::Option<Value>,
    #[prost(message, optional, tag="4")]
    pub label: ::core::option::Option<strict_quad::Ref>,
}
/// Nested message and enum types in `StrictQuad`.
pub mod strict_quad {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(oneof="r#ref::Value", tags="2, 3")]
        pub value: ::core::option::Option<r#ref::Value>,
    }
    /// Nested message and enum types in `Ref`.
    pub mod r#ref {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Value {
            #[prost(string, tag="2")]
            BnodeLabel(::prost::alloc::string::String),
            #[prost(string, tag="3")]
            Iri(::prost::alloc::string::String),
        }
    }
}
/// StrictQuadRaw is the same as StrictQuad, but doesn't decode underlying values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StrictQuadRaw {
    #[prost(bytes="vec", tag="1")]
    pub subject: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub predicate: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="3")]
    pub object: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="4")]
    pub label: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof="value::Value", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
    pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TypedString {
        #[prost(string, tag="1")]
        pub value: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub r#type: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LangString {
        #[prost(string, tag="1")]
        pub value: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub lang: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Timestamp {
        #[prost(int64, tag="1")]
        pub seconds: i64,
        #[prost(int32, tag="2")]
        pub nanos: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(bytes, tag="1")]
        Raw(::prost::alloc::vec::Vec<u8>),
        #[prost(string, tag="2")]
        Str(::prost::alloc::string::String),
        #[prost(string, tag="3")]
        Iri(::prost::alloc::string::String),
        #[prost(string, tag="4")]
        Bnode(::prost::alloc::string::String),
        #[prost(message, tag="5")]
        TypedStr(TypedString),
        #[prost(message, tag="6")]
        LangStr(LangString),
        #[prost(int64, tag="7")]
        Int(i64),
        #[prost(double, tag="8")]
        Float(f64),
        #[prost(bool, tag="9")]
        Boolean(bool),
        #[prost(message, tag="10")]
        Time(Timestamp),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Header {
    /// Full is set if encoder always writes every quad directions instead of
    /// skipping duplicated values on each direction (except label) for subsequent quads.
    #[prost(bool, tag="1")]
    pub full: bool,
    /// NotStrict is set if encoder emits WireQuad instead of StrictQuad messages.
    #[prost(bool, tag="2")]
    pub not_strict: bool,
}
// @@protoc_insertion_point(module)
